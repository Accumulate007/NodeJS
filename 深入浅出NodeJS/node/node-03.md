#### 内存控制

**V8的垃圾回收机制和内存限制**

V8作为一款JavaScript的虚拟机，从出现到现在一直领跑。

在Node中通过JavaScript使用内存只能使用部分内存(64位系统下约为1.4GB，32位系统下约为0.7GB)。

当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。直到堆的大小超过V8的限制为止。

V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间开销下，应用的性能和响应能力都会直线下降。这也是V8限制内存使用大小的一个根本原因。

可以通过初始化设置，放宽V8的内存使用限制
```javascript
node --max-old-space-size=1700  index.js    // 单位为MB(设置老生代内存空间的最大值)

node --max-new-space-size=1024  index.js    // 单位为KB(设置新生代内存空间的最大值)

// 初始化生效后就不能再动态修改
```

**分代式垃圾回收机制**

在实际的应用中，因为对象的生存周期长短不一，不同的算法只能针对特定情况才有最好的效果。现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。

V8主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或者是常驻内存的对象。
- 新生代中的对象主要通过Scavenge算法进行垃圾回收。它将堆内存一分为二，只有一个处于使用中(From空间)，另一个处于闲置状态(To空间)。开始垃圾回收时，From空间中的存活对象会被复制到To空间，非存活对象的空间会被释放。完成复制后，From空间和To空间的角色发生对换。
- 当一个对象在新生代内存中经过多次复制依然存在时，它会被认为时生命周期较长的对象。会被移到老生代中，采用新的算法管理，对象从新生代中移到老生代的过程称为晋升。对象晋升的条件主要有两个：a.对象是否经历过Scavenge回收；b.To空间的内存占用比例是否超过限制(25%)。
- V8在老生代中主要采用Mark-Sweep(标记清除)和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep在标记阶段遍历堆中的所有对象，并标记存活的对象，在随后的清理阶段只清除没有被标记的对象。但是这种方式，会造成内存空间出现不连续的状态，称为内存碎片问题。Mark-Compact和Mark-Sweep的差别在于，在整理的过程中将活着的对象往一端移动，移动完成后直接清除掉边界外的内存。

综上，V8中使用的堆内存是新生代的两个空间和老生代所用内存大小之和。

并且，V8垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完毕垃圾回收后再恢复执行应用逻辑。

为了降低 全堆垃圾回收带来的停顿时间，V8从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记(incremental marking)，也就是拆分为许多小“步进”。垃圾回收与应用逻辑交替执行直到标记阶段完成。

**查看垃圾回收日志**

启动应用时添加--trace_gc参数可以从标准输出中打印垃圾回收的日志信息
```javascript
node --trace_gc index.js
```

--prof可以得到V8执行时候的性能分析数据
```javascript
node --prof test.js
```

**高效使用内存**

1.主动释放变量

如果变量是全局变量，由于全局作用域需要直到进程退出才能释放，将导致引用的对象常驻内存。可以通过delete操作删除引用关系，或者将变量赋值为null释放。

2.闭包

JavaScript中实现外部作用域访问内部作用域中变量的方法叫做闭包(closure)。


**内存泄漏**

内存泄漏的本质就是应该回收的对象出现意外而没有被回收，变成了常驻内存的老生代中的对象。主要原因有
- 缓存
- 队列消费不及时
- 作用域未释放

**大内存应用**

Node中提供了stream模块用于处理大文件。

